Options
=======
Многие из вас уже знакомы с типом `Optional` в `Java 8`. К тому же ранее мы его
использовали. Тип `Option` выполняет те же функции. Более того, многим джавистам
данный тип может быть знаком по библиотеке `Guava` от `Google`.

Да, этот тип используется для избежания `null`, а в последствии и
`NullPointerException`. Да, у него есть методы `isEmpty`, и `nonEmpty`. В
варианте `Guava` есть метод `isPresent`. И многие, кто использовал или не
использовал Optional в `Java` или других языках, неправильно использует его в
`Scala`.

Неправильное использование `Option`, является распространенной проблемой.
`Option`, в **первую очередь** нужен для того чтобы **концептуально** показать
возможно отсутствующую сущность. А не убегать от NPE. Да проблема есть, и
проблема серьезная. Кто-то для этого даже язык свой изобретает.

Но давайте вернемся к неправильному использованию `Option` в `Scala`:

    if (option.isEmpty)
      default
    else
      // может взорватся c NoSuchElementException (без проверки)
      option.get

Да, мы делаем проверку, и у нас вроде бы ничто не должно взорваться. Поверьте,
в промышленном коде можно ошибиться, и в условии может оказаться совсем не то
выражение, которое ожидалось. И даже тесты могут быть написаны неправильно Не
вами, так вашими предшественниками. Некоторые разработчики имеют свойство
подгонять тесты под уже "работающий" код.

Правильнее, и **короче**, данный код можно записать так:

    option getOrElse default

Чем компактнее ваш код, тем легче найти в нем ошибку, и тем сложнее эту ошибку
допустить. Существует полезный метод `orElse` который позволяет сцеплять
различные `Option`.

Зачастую, вам нужно трансформировать значение внутри Option, если оно вообще там
имеется. Для этого существует метод `map`, он вынимает значение, преобразовывает
его, и упаковывает обратно в контейнер.

    val messageOpt = Some("Hello")
    val updMessageOpt = messageOpt.map(msg => "$mgs cruel world!")

    updMessageOpt: Option[String]


А иногда бывает и такое:

    val messageOptOpt = Some(Some("Hello"))

`Option` могут безмерно вкладываются друг в друга. Эту проблему решает метод
`flatMap`. Или метод `flatten`. Первый, работает аналогично `map` -- он
трансформирует внутреннее значение, Однако при
этом он уплощает структуру, второй просто
упрощает структуру:

    val updMessageOptOpt = messageOptOpt.flatMap(msg => "$mgs cruel world!")
    res0: updMessageOptOpt: Option[String]

    messageOptOpt.flatten == Some("Hello")
    res1: Option[String] = Some(Hello)

В `Scala` существует еще один механизм который заметно облегчает работу с
`Option`, и это... `For comprehension`

    val ox = Some(1)
    val oy = Some(2)
    val oz = Some(3)

    for (x <- ox; y <- oy; z <- oz)
      yield x + y + z

    // res0: Option[Int] = 6

В случае, если какой-то из Option типов будет равен None. То после `yield`
пользователь получит пустой контейнер, вернее значение пустого контейнера, в
случае с `Option` это `None`. В случае со списком: `Nil`.

И главное, старайтесь сделать все, лишь бы не вызывать метод `get`. Это ведет
к потенциальным проблемам.


Литература
==========
[Здесь][opt-guide] очень хорошо описано, как лучше использовать `Option`. Пускай
многое в этом [видео][opt-video-1] вам не будет понятно, вернитесь к нему позже,
когда понимание `Scala` станет немного лучше.

[Шпаргалка][opt-cheat-sheet], которая, возможно, будет вам полезной.

[opt-guide]: http://danielwestheide.com/blog/2012/12/19/the-neophytes-guide-to-scala-part-5-the-option-type.html
[opt-video-1]: https://www.youtube.com/watch?v=gVXt1RG_yN0
[opt-cheat-sheet]: http://blog.tmorris.net/posts/scalaoption-cheat-sheet/

