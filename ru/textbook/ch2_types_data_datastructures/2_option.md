Options
=======
Многие из вас уже знакомы с типом `Optional` в `Java`. К тому же ранее
мы его использовали. Тип `Option` выполняет те же функции. Более того,
многим java-разработчикам данный тип может быть знаком по библиотеке
`Guava` от `google`.

Да, этот тип используется для избежания `null`, а в последствии и
`NullPointerException`. Да, у него есть методы `isEmpty`, и `nonEmpty`.
В варианте `Guava` есть метод `isPresent`. И многие, кто использовал
или не использовал Optional в `Java` или других языках, неправильно
использует его в `Scala`.

Неправильное использование Option, является распространенной проблемой.
`Option`, в **первую очередь** нужен для того чтобы **концептуально**
показать возможно отсутствующую сущность. А не убегать от NPE. Да
проблема есть, и проблема серьезная. Кто-то для этого даже язык свой
изобретает.

Но давайте вернемся к неправильному использованию `Option` в `Scala`:

    if (option.isEmpty)
      default
    else
      // может взорватся c NoSuchElementException (без проверки)
      option.get

Да, мы делаем проверку, и у нас вроде бы ничто не должно взорваться.
Но поверьте, в промышленном коде можно ошибиться, и в условии может
оказаться совсем не то выражение, которое ожидалось. И даже тесты могут
быть написаны неправильно. Не вами, так вашими предшественниками.

Правильнее, и **короче**, данный код можно записать так:

    option getOrElse default

Чем компактнее ваш код, тем легче найти в нем ошибку, и тем сложнее эту
ошибку допустить. Существует полезный метод `orElse` который позволяет
сцеплять различные `Option`.

Зачастую, вам нужно трансформировать значение внутри Option, если оно
вообще там имеется. Для этого существует метод `map`, он вынимает
значение, преобразовывает его, и упаковывает обратно в контейнер.

    val messageOpt = Some("Hello")
    val updMessageOpt = messageOpt.map(msg => "$mgs cruel world!")

    updMessageOpt: Option[String]


А иногда бывает и такое:

    val messageOptOpt = Some(Some("Hello"))

`Option` растут и безмерно вкладываются друг в друга. Эту проблему
решает метод `flatMap`. Или метод `flatten`. Первый, работает аналогично
`map`, Однако при этом делает структуру более.. "плоской", второй просто
упрощает структуру:

    val updMessageOptOpt = messageOptOpt.flatMap(msg => "$mgs cruel world!")
    updMessageOptOpt: Option[String]

    messageOptOpt.flatten == Some("Hello")
    > true

В `Scala` существует еще один механизм который заметно облегчает работу с
`Option`, и это... `For comprehension`

    val ox = Some(1)
    val oy = Some(2)
    val oz = Some(3)

    for (x <- ox; y <- oy; z <- oz)
      yield x + y + z

    // res0: Option[Int] = 6

В случае, если какой-то из Option типов будет равен None. То после
`yield` пользователь получит пустой контейнер, вернее значение пустого
контейнера, в случае с `Option` это `None`. В случае со списком: `Nil`.

И главное, старайтесь сделать все, лишь бы не вызывать метод `get`.
Извивайтесь ужом, выпрыгивайте из себя. `get` убивает не хуже никотина.


Литература
==========
[Здесь][opt-guide] очень хорошо описано, как лучше использовать `Option`
Пускай многое в этом [видео][1] вам не будет понятно, вернитесь к нему
позже, когда понимание `Scala` станет немного лучше.

[Шпаргалка][2], которая, возможно, будет вам полезной.

[opt-guide]: http://danielwestheide.com/blog/2012/12/19/the-neophytes-guide-to-scala-part-5-the-option-type.html
[1]: https://www.youtube.com/watch?v=gVXt1RG_yN0
[2]: http://blog.tmorris.net/posts/scalaoption-cheat-sheet/

