Кортежи
=======
Наличие кортежей (tuples) -- замечательнейшая особенность функциональных
языков. В функциональных языках, кортежи очень удобно использовать
аналогично записям (records): берем кортеж, складываем в него все
необходимое, и оборачиваем в новый тип, например используя `newtype` в
Haskell[1]. В чисто-функциональных языках без кортежей никуда: они
позволяют замечательно представлять словари (dictionaries), без них было
[конволюция](convolution) была бы менее наглядной.

Scala язык объектно-ориентированный. Да, с поддержкой элементов
функционального программирования. Уверен, что многие со мной не
согласятся, но давайте не будем забывать что в Scala все есть объект.
Наличие case классов во многом снижает необходимость в кортежах: мы
получаем неизменяемые записи, которые так же можно сопоставлять с
образцами (об этом будет рассказано далее), с каждым case классом уже
связан свой тип.

Кортежи приходится использовать, и пришедшим из объектно-ориентированных
языков, данные языковые средства в диковинку. Во-первых, их не именуют.

> Если кортеж не используется как анонимная помойка, его следует
> именовать

Для функционального стиля хорошим тоном считается использование
псевдонимов для типов (type aliasing):

    type Point = (Double, Double)

В будущем вы ссылаетесь на вполне себе именованные тип, и у вас не будет
вот таких страшных вещей:

    // плохо
    def drawLine(x: (Double, Double), y: (Double, Double)): Line = ???

    // не плохо
    def drawLine(x: Point, y: Point): Line = ???


В Scala, достучаться до элемента кортежа можно по индексу. Например:

    // Плохо!
    val y = point._2 // второй элемент

Особенно печально это выглядит при работе с коллекциями:

    // Печально!
    points foreach { point: Point =>
      println(s"x: ${point._1}, y: ${point._2}")
    }

И так делать не надо. Конечно же есть исключительные случаи, когда
подобного рода меры повышают читаемость:

    // Оправданно
    rows.groupBy(_._2)

Но в большинстве случаев, синтаксис с подчеркиванием лучше не
использовать. Про него вообще лучше забыть, и не вспоминать. В Scala
существуют более естественные способы обходиться без подобного
синтаксиса.

> В Scala всегда можно обойтись без pair._2. И это нужно делать.
> Пожалейте ваших коллег, или будущего себя.

Чтобы понять и разобраться почему все именно так давайте обратимся к
функциональным языкам.

Почему индексы списков в Scala начинаются с 0, а кортежей с единицы?
Ответ: потому что так исторически сложилось. В `SML` для доступа к
элементам списка существуют [функции](tuples_in_sml) `#1` и `#2`.
В Haskell существуют всего две функции для доступа к элементам кортежа:
`fst` и `snd`.

    -- Как-то так. В Haskell аргументы функции идут сразу же после имени
    -- этой самой функции. Без скобок.
    fst tuple

А вот получить третий или пятый элемент кортежа просто так уже не
получится. Не верите? А [зря](tuples_in_haskell). И не поверите, если я
вам скажу что сопоставление с образцом это *наиболее естественный*.
И не только в Haskell.

**Ocaml**

    let third (_, _, elem) = elem

**Erlang**

    1> Tuple = {1,3,4}.
    {1,3,4}

    2> Third = fun ({_Fst, _Snd, Thrd}) -> Thrd end.
    #Fun<erl_eval.6.50752066>

    3> Third(Tuple).
    4

**Python**
А вот вам пример не из функционального языка:

    >> (ip, hostname) = ("127.0.0.1", "localhost")
    >>> ip
    '127.0.0.1'
    >>> hostname
    'localhost'
    >>>

А теперь давайте применим полученные знания к **Scala**

    // предположим у нас есть прямоугольник
    trait Rectangle {
      def topLeft: Point
      ...
    }

    // сопоставления с образцом при связывании
    val (x0, y0) = rectangle.topLeft

    // сопоставление с образцом внутри лямбды:
    points foreach { case (x, y) =>
      println(s"x: ${x}, y: ${y}")
    }

И да, стандартный механизм сопоставления с образцом никто не отменял.

> Так же кортежи можно использовать как анонимные помойки, и это
> порой оправданно

Дело в том что во многих функциональных языках существует сопоставление
с образцом на уровне сигнатур функций:

    -- немного кода на haskell
    -- здесь описываются типы:
    map :: (a -> b) -> [a] -> [b]

    -- а вот тут сопоставление с образцом на уровне
    -- сигнатуры функции

    -- если нашим аргументом является
    -- пустой список:
    map _ []  =  []

    -- более идиоматично было бы ипользование x:xs
    -- но, считаю что для людей Haskell не знающих head:tail
    -- будет нагляднее
    map fun (head:tail) = fun head : map fun tail

Аналогично для `SML` или `Erlang`. Scala такой возможности лишена. Поэтому
кортежи можно использовать для группировки и последующего сопоставления
с образцом. И да, это будет вам стоить производительности (каждый раз
будет создаваться дополнительный объект в памяти):

    // похоже на Haskell, но не то :(
    def map [A, B] (f: A => B, l: List[A]): List[B] = (f, l) match {
        case (f, Nil) => List.empty
        case (f, head::tail) => f(head) :: map(f, tail)
    }

Зачастую нам бывает необходимо обновить значение в каком-то из элементов
кортежа. Для этого подойдет метод `copy`.

    val dog = ("Rex", 13)
    val olderDog = tuple.copy(_2 = 14)


Литература
==========
[Раздел][1] wiki-книги о Scala, посвященный кортежам.

[1]: https://en.wikibooks.org/wiki/Scala/Tuples
[convolution]: https://en.wikipedia.org/wiki/Convolution_(computer_science)
[tuples_in_haskell]: http://stackoverflow.com/questions/15558278/how-to-get-nth-element-from-a-10-tuple-in-haskell
[tuples_in_sml]: http://www.cs.cornell.edu/courses/cs312/2004fa/lectures/lecture3.htm

