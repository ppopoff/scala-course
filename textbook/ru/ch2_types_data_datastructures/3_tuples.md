Кортежи
=======
Наличие кортежей (tuples) — замечательнейшая особенность ряда функциональных (и
не только) языков. В функциональных языках кортежи очень удобно использовать
аналогично записям (records). Описываем кортеж с нужными данными и оборачиваем
в новый тип, например, используя `newtype` в [Haskell](haskell_newtype). В
чисто функциональных языках без кортежей никуда: они позволяют замечательно
представлять словари (dictionaries), без них было [конволюция](convolution) была
бы менее наглядной.

Scala — язык объектно-ориентированный. Да, с поддержкой элементов
функционального программирования. Уверен, что многие со мной не согласятся, но
давайте не будем забывать, что в Scala все есть объект. Наличие case-классов во
многом снижает необходимость кортежец: мы получаем неизменяемые записи,
которые тоже можно сопоставлять с образцами (об этом расскажем далее),
с каждым case-классом уже связан свой тип.

Кортежи приходится использовать, и пришедшим из объектно-ориентированных
Языков эти языковые средства — в диковинку. Во-первых, их не именуют.

> Если кортеж не используется как анонимная помойка, его следует
> именовать

Для функционального стиля хорошим тоном считается использование
псевдонимов для типов (type aliasing):

    type Point = (Double, Double)

В будущем вы ссылаетесь на вполне себе именованные тип, и у вас не будет
вот таких страшных вещей:

    // плохо
    def drawLine(x: (Double, Double), y: (Double, Double)): Line = ???

    // не плохо
    def drawLine(x: Point, y: Point): Line = ???


В Scala, достучаться до элемента кортежа можно по индексу. Например:

    // Плохо!
    val y = point._2 // второй элемент

Особенно печально это выглядит при работе с коллекциями:

    // Печально!
    points foreach { point: Point =>
      println(s"x: ${point._1}, y: ${point._2}")
    }

И так делать не надо. Конечно, есть исключительные случаи, когда подобного
рода меры повышают читаемость:

    // Оправданно
    rows.groupBy(_._2)

Но в большинстве случаев, синтаксис с подчеркиванием лучше не использовать.
Про него вообще лучше забыть, и не вспоминать. В Scala существуют более
естественные способы обходиться без подобного синтаксиса.

> В Scala всегда можно обойтись без pair._2. И это нужно делать.

Чтобы понять и разобраться, почему все именно так, давайте обратимся к
функциональным языкам.

Вопрос: Почему индексы списков в Scala начинаются с 0, а кортежей — с единицы?
Ответ: потому что так исторически сложилось. В SML для доступа к элементам
кортежа существуют [функции](tuples_in_sml) `#1` и `#2`. В `Haskell` существуют
всего две функции для доступа к элементам кортежа: “fst” и “snd”.

    -- Как-то так. В Haskell аргументы функции идут сразу же после имени
    -- этой самой функции. Без скобок.
    fst tuple

А вот получить третий или пятый элемент кортежа просто так уже не получится. Не
верите? А [зря](tuples_in_haskell). И не поверите, если я вам скажу, что
сопоставление с образцом — *наиболее естественный*. И не только в `Haskell`.

**Ocaml**

    let third (_, _, elem) = elem

**Erlang**

    1> Tuple = {1,3,4}.
    {1,3,4}

    2> Third = fun ({_Fst, _Snd, Thrd}) -> Thrd end.
    #Fun<erl_eval.6.50752066>

    3> Third(Tuple).
    4

**Python**
А вот вам пример не из функционального языка:

    >> (ip, hostname) = ("127.0.0.1", "localhost")
    >>> ip
    '127.0.0.1'
    >>> hostname
    'localhost'
    >>>

А теперь давайте применим полученные знания к **Scala**

    // предположим, у нас есть прямоугольник
    trait Rectangle {
      def topLeft: Point
      ...
    }

    // сопоставления с образцом при связывании
    val (x0, y0) = rectangle.topLeft

    // сопоставление с образцом внутри лямбды:
    points foreach { case (x, y) =>
      println(s"x: ${x}, y: ${y}")
    }

И да, стандартный механизм сопоставления используя ключевое слово `match` тоже
никто не отменял.

> Также кортежи можно использовать как анонимные помойки, и это
> порой оправданно.

Дело в том, что во многих функциональных языках существует сопоставление
с образцом на уровне сигнатур функций:

    -- немного кода на haskell
    -- здесь описываются типы:
    map :: (a -> b) -> [a] -> [b]

    -- а вот тут сопоставление с образцом на уровне
    -- сигнатуры функции

    -- если нашим аргументом является
    -- пустой список:
    map _ []  =  []

    -- более идиоматично было бы использование x:xs но, считаю, для не
    -- знающих Haskell head:tail будет нагляднее. : - оператор именуемый cons
    -- является эквивалентным скаловскому ::
    map fun (head:tail) = fun head : map fun tail

Аналогично для SML или Erlang. Scala такой возможности лишена. Поэтому
кортежи можно использовать для группировки и последующего сопоставления
с образцом. И да, это будет вам стоить производительности (каждый раз
будет создаваться дополнительный объект в памяти):

    // похоже на Haskell, но не то :(
    def map [A, B] (f: A => B, l: List[A]): List[B] = (f, l) match {
        case (f, Nil) => List.empty
        case (f, head::tail) => f(head) :: map(f, tail)
    }

Зачастую бывает необходимо обновить значение в каком-то из элементов
кортежа. Для этого подойдет метод “copy”.

    val dog = ("Rex", 13)
    val olderDog = tuple.copy(_2 = 14)


Литература
==========
[Раздел][scala-wiki-tuples] wiki-книги о Scala, посвященный кортежам.

[scala-wiki-tuples]: https://en.wikibooks.org/wiki/Scala/Tuples
[convolution]: https://en.wikipedia.org/wiki/Convolution_(computer_science)
[tuples_in_haskell]: http://stackoverflow.com/questions/15558278/how-to-get-nth-element-from-a-10-tuple-in-haskell
[tuples_in_sml]: http://www.cs.cornell.edu/courses/cs312/2004fa/lectures/lecture3.htm
[haskell_newtype]: https://wiki.haskell.org/Newtype

