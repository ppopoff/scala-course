Options
=======
Многие из вас уже знакомы с типом “Optional” в Java 8. К тому же, раньше мы его
использовали. Тип “Option” выполняет те же функции. Более того, многим
джавистам тип может быть знаком по библиотеке Guava от Google.

Да, этот тип используется для избегания `null`, а в последствии — и
`NullPointerException`. Да, у него есть методы `isEmpty` и `nonEmpty`. В
варианте Guava есть метод “isPresent”. И многие, кто использовал или не
использовал Optional в Java или других языках, неправильно использует его в
Scala.

Неправильное использование Option — распространенная проблема.
Option, в **первую очередь**, нужен,чтобы **концептуально** показать
возможно отсутствующую сущность. А не убегать от NPE. Да, проблема есть, и
проблема серьезная. Кто-то для этого даже язык свой изобретает.

Но давайте вернемся к неправильному использованию Option в Scala:

    if (option.isEmpty)
      default
    else
      // может взорватся c NoSuchElementException (без проверки)
      option.get

Мы делаем проверку, и у нас, вроде бы, ничто не должно взорваться. Поверьте,
в промышленном коде можно ошибиться, и в условии может оказаться совсем не то
выражение, которое ожидалось. И даже тесты могут быть написаны неправильно Не
вами, так вашими предшественниками. Некоторые разработчики имеют свойство
подгонять тесты под уже «работающий» код.

Правильнее и **короче** код можно записать так:

    option getOrElse default

Чем компактнее ваш код, тем легче найти в нем ошибку, и тем сложнее эту ошибку
допустить. Существует полезный метод `orElse`, который позволяет сцеплять
различные Option.

Зачастую вам нужно трансформировать значение внутри Option, если оно вообще там
имеется. Для этого существует метод `map`, он вынимает значение,
преобразовывает его и упаковывает обратно в контейнер.

    val messageOpt = Some("Hello")
    val updMessageOpt = messageOpt.map(msg => "$mgs cruel world!")

    updMessageOpt: Option[String]


А иногда бывает и такое:

    val messageOptOpt = Some(Some("Hello"))

Option могут безмерно вкладываются друг в друга. Эту проблему решает метод
`flatMap` или метод `flatten`. Первый работает аналогично `map` — он
трансформирует внутреннее значение, однако при
этом уплощает структуру$ второй просто
упрощает структуру:

    val updMessageOptOpt = messageOptOpt.flatMap(msg => "$mgs cruel world!")
    res0: updMessageOptOpt: Option[String]

    messageOptOpt.flatten == Some("Hello")
    res1: Option[String] = Some(Hello)

В Scala существует еще один механизм который заметно облегчает работу с
Option, и это... “For comprehension”.`

    val ox = Some(1)
    val oy = Some(2)
    val oz = Some(3)

    for (x <- ox; y <- oy; z <- oz)
      yield x + y + z

    // res0: Option[Int] = 6

Если какой-то из Option-типов будет равен `None`, после `yield` пользователь
получит пустой контейнер, вернее, значение пустого контейнера. В случае с
Option это None. В случае со списком — Nil.

И главное, старайтесь сделать все, лишь бы не вызывать метод `get`. Это ведет
к потенциальным проблемам.


Литература
==========
[Здесь][opt-guide] очень хорошо описано, как лучше использовать Option. Пускай
многое в этом [видео][opt-video-1] вам не будет понятно, вернитесь к нему позже,
когда понимание Scala станет немного лучше.

[Шпаргалка][opt-cheat-sheet], которая, возможно, будет вам полезна.

[opt-guide]: http://danielwestheide.com/blog/2012/12/19/the-neophytes-guide-to-scala-part-5-the-option-type.html
[opt-video-1]: https://www.youtube.com/watch?v=gVXt1RG_yN0
[opt-cheat-sheet]: http://blog.tmorris.net/posts/scalaoption-cheat-sheet/

